<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "32bd800759c3e943c38ad9ae6e1f51e0",
  "translation_date": "2025-10-24T21:38:11+00:00",
  "source_file": "7-bank-project/4-state-management/README.md",
  "language_code": "sk"
}
-->
# Vytvorenie bankovej aplik√°cie, ƒças≈• 4: Koncepty spr√°vy stavu

## Kv√≠z pred predn√°≈°kou

[Predn√°≈°kov√Ω kv√≠z](https://ff-quizzes.netlify.app/web/quiz/47)

## √övod

Spr√°va stavu je ako navigaƒçn√Ω syst√©m na kozmickej lodi Voyager ‚Äì keƒè v≈°etko funguje hladko, sotva si ho v≈°imnete. Ale keƒè sa nieƒço pokaz√≠, st√°va sa rozdielom medzi dosiahnut√≠m medzihviezdneho priestoru a bl√∫den√≠m v kozmickom pr√°zdne. Vo webovom v√Ωvoji stav predstavuje v≈°etko, ƒço si va≈°a aplik√°cia potrebuje pam√§ta≈•: stav prihl√°senia pou≈æ√≠vateƒæa, √∫daje formul√°ra, hist√≥riu navig√°cie a doƒçasn√© stavy rozhrania.

Ako sa va≈°a bankov√° aplik√°cia vyv√≠jala z jednoduch√©ho prihlasovacieho formul√°ra na sofistikovanej≈°iu aplik√°ciu, pravdepodobne ste narazili na niektor√© be≈æn√© v√Ωzvy. Obnov√≠te str√°nku a pou≈æ√≠vatelia s√∫ neoƒçak√°vane odhl√°sen√≠. Zatvor√≠te prehliadaƒç a v≈°etok pokrok zmizne. Hƒæad√°te chybu a prech√°dzate viacer√Ωmi funkciami, ktor√© v≈°etky upravuj√∫ rovnak√© √∫daje r√¥znymi sp√¥sobmi.

Toto nie s√∫ znaky zl√©ho k√≥dovania ‚Äì s√∫ to prirodzen√© probl√©my, ktor√© sa objavuj√∫, keƒè aplik√°cie dosiahnu urƒçit√Ω prah zlo≈æitosti. Ka≈æd√Ω v√Ωvoj√°r ƒçel√≠ t√Ωmto v√Ωzvam, keƒè sa jeho aplik√°cie pos√∫vaj√∫ z f√°zy ‚Äûd√¥kaz konceptu‚Äú do f√°zy ‚Äûpripraven√© na produkciu‚Äú.

V tejto lekcii implementujeme centralizovan√Ω syst√©m spr√°vy stavu, ktor√Ω premen√≠ va≈°u bankov√∫ aplik√°ciu na spoƒæahliv√∫, profesion√°lnu aplik√°ciu. Nauƒç√≠te sa predv√≠dateƒæne spravova≈• tok √∫dajov, vhodne uchov√°va≈• pou≈æ√≠vateƒæsk√© rel√°cie a vytv√°ra≈• plynul√Ω pou≈æ√≠vateƒæsk√Ω z√°≈æitok, ktor√Ω modern√© webov√© aplik√°cie vy≈æaduj√∫.

## Predpoklady

Predt√Ωm, ne≈æ sa pust√≠te do konceptov spr√°vy stavu, mus√≠te ma≈• spr√°vne nastaven√© v√Ωvojov√© prostredie a z√°klad va≈°ej bankovej aplik√°cie. T√°to lekcia priamo nadv√§zuje na koncepty a k√≥d z predch√°dzaj√∫cich ƒçast√≠ tejto s√©rie.

Uistite sa, ≈æe m√°te pripraven√© nasleduj√∫ce komponenty pred pokraƒçovan√≠m:

**Po≈æadovan√© nastavenie:**
- Dokonƒçite [lekciu o z√≠skavan√≠ √∫dajov](../3-data/README.md) - va≈°a aplik√°cia by mala √∫spe≈°ne naƒç√≠ta≈• a zobrazova≈• √∫daje o √∫ƒçte
- Nain≈°talujte si [Node.js](https://nodejs.org) na v√°≈° syst√©m na spustenie backendov√©ho API
- Spustite [server API](../api/README.md) lok√°lne na spracovanie oper√°ci√≠ s √∫dajmi o √∫ƒçte

**Testovanie v√°≈°ho prostredia:**

Overte, ≈æe v√°≈° API server funguje spr√°vne, vykonan√≠m tohto pr√≠kazu v termin√°li:

```sh
curl http://localhost:5000/api
# -> should return "Bank API v1.0.0" as a result
```

**ƒåo tento pr√≠kaz rob√≠:**
- **Odosiela** GET po≈æiadavku na v√°≈° lok√°lny API server
- **Testuje** pripojenie a overuje, ƒçi server odpoved√°
- **Vracia** inform√°cie o verzii API, ak v≈°etko funguje spr√°vne

---

## Diagnostika aktu√°lnych probl√©mov so stavom

Ako Sherlock Holmes sk√∫maj√∫ci miesto ƒçinu, mus√≠me presne pochopi≈•, ƒço sa deje v na≈°ej aktu√°lnej implement√°cii, aby sme mohli vyrie≈°i≈• z√°hadu mizn√∫cich pou≈æ√≠vateƒæsk√Ωch rel√°ci√≠.

Vykonajme jednoduch√Ω experiment, ktor√Ω odhal√≠ z√°kladn√© probl√©my spr√°vy stavu:

**üß™ Sk√∫ste tento diagnostick√Ω test:**
1. Prihl√°ste sa do svojej bankovej aplik√°cie a prejdite na dashboard
2. Obnovte str√°nku prehliadaƒça
3. Sledujte, ƒço sa stane s va≈°√≠m stavom prihl√°senia

Ak ste presmerovan√≠ sp√§≈• na prihlasovaciu obrazovku, objavili ste klasick√Ω probl√©m s uchov√°van√≠m stavu. Toto spr√°vanie nast√°va, preto≈æe na≈°a aktu√°lna implement√°cia uchov√°va √∫daje pou≈æ√≠vateƒæa v JavaScriptov√Ωch premenn√Ωch, ktor√© sa pri ka≈ædom naƒç√≠tan√≠ str√°nky resetuj√∫.

**Probl√©my aktu√°lnej implement√°cie:**

Jednoduch√° premenn√° `account` z na≈°ej [predch√°dzaj√∫cej lekcie](../3-data/README.md) sp√¥sobuje tri v√Ωznamn√© probl√©my, ktor√© ovplyv≈àuj√∫ pou≈æ√≠vateƒæsk√∫ sk√∫senos≈• aj udr≈æiavateƒænos≈• k√≥du:

| Probl√©m | Technick√° pr√≠ƒçina | Dopad na pou≈æ√≠vateƒæa |
|---------|-------------------|----------------------|
| **Strata rel√°cie** | Obnovenie str√°nky vyma≈æe JavaScriptov√© premenn√© | Pou≈æ√≠vatelia sa musia ƒçasto znovu autentifikova≈• |
| **Roztr√∫sen√© aktualiz√°cie** | Viacer√© funkcie priamo upravuj√∫ stav | Ladenie sa st√°va ƒçoraz ≈•a≈æ≈°√≠m |
| **Ne√∫pln√© vyƒçistenie** | Odhl√°senie nevyma≈æe v≈°etky referencie stavu | Potenci√°lne bezpeƒçnostn√© a s√∫kromn√© probl√©my |

**Architektonick√° v√Ωzva:**

Ako pri n√°vrhu Titanic, ktor√Ω sa zdal robustn√Ω, k√Ωm sa naraz nezaplavilo viacero oddelen√≠, rie≈°enie t√Ωchto probl√©mov jednotlivo neodstr√°ni z√°kladn√Ω architektonick√Ω probl√©m. Potrebujeme komplexn√© rie≈°enie spr√°vy stavu.

> üí° **ƒåo sa tu vlastne sna≈æ√≠me dosiahnu≈•?**

[Spr√°va stavu](https://en.wikipedia.org/wiki/State_management) je v podstate o rie≈°en√≠ dvoch z√°kladn√Ωch h√°daniek:

1. **Kde s√∫ moje √∫daje?**: Sledovanie toho, ak√© inform√°cie m√°me a odkiaƒæ poch√°dzaj√∫
2. **Je ka≈æd√Ω na rovnakej vlne?**: Zabezpeƒçenie, ≈æe to, ƒço pou≈æ√≠vateƒæ vid√≠, zodpoved√° tomu, ƒço sa skutoƒçne deje

**N√°≈° pl√°n:**

Namiesto toho, aby sme sa nah√°≈àali za probl√©mami, vytvor√≠me **centralizovan√Ω syst√©m spr√°vy stavu**. Predstavte si to ako ma≈• jedn√©ho naozaj organizovan√©ho ƒçloveka, ktor√Ω m√° na starosti v≈°etky d√¥le≈æit√© veci:

![Sch√©ma zobrazuj√∫ca tok √∫dajov medzi HTML, pou≈æ√≠vateƒæsk√Ωmi akciami a stavom](../../../../translated_images/data-flow.fa2354e0908fecc89b488010dedf4871418a992edffa17e73441d257add18da4.sk.png)

**Pochopenie tohto toku √∫dajov:**
- **Centralizuje** v≈°etky stavy aplik√°cie na jednom mieste
- **Routuje** v≈°etky zmeny stavu cez kontrolovan√© funkcie
- **Zabezpeƒçuje**, ≈æe pou≈æ√≠vateƒæsk√© rozhranie zost√°va synchronizovan√© s aktu√°lnym stavom
- **Poskytuje** jasn√Ω, predv√≠dateƒæn√Ω vzor pre spr√°vu √∫dajov

> üí° **Profesion√°lny pohƒæad**: T√°to lekcia sa zameriava na z√°kladn√© koncepty. Pre komplexn√© aplik√°cie poskytuj√∫ kni≈ænice ako [Redux](https://redux.js.org) pokroƒçilej≈°ie funkcie spr√°vy stavu. Pochopenie t√Ωchto z√°kladn√Ωch princ√≠pov v√°m pom√¥≈æe zvl√°dnu≈• ak√∫koƒævek kni≈ænicu na spr√°vu stavu.

> ‚ö†Ô∏è **Pokroƒçil√° t√©ma**: Nebudeme sa zaobera≈• automatick√Ωmi aktualiz√°ciami pou≈æ√≠vateƒæsk√©ho rozhrania vyvolan√Ωmi zmenami stavu, preto≈æe to zah≈ï≈àa koncepty [Reakt√≠vneho programovania](https://en.wikipedia.org/wiki/Reactive_programming). Pova≈æujte to za vynikaj√∫ci ƒèal≈°√≠ krok vo va≈°ej uƒçebnej ceste!

### √öloha: Centraliz√°cia ≈°trukt√∫ry stavu

Zaƒçnime transform√°ciou na≈°ej roztr√∫senej spr√°vy stavu na centralizovan√Ω syst√©m. Tento prv√Ω krok vytv√°ra z√°klad pre v≈°etky nasleduj√∫ce vylep≈°enia.

**Krok 1: Vytvorenie centralizovan√©ho objektu stavu**

Nahraƒète jednoduch√© vyhl√°senie `account`:

```js
let account = null;
```

≈†trukt√∫rovan√Ωm objektom stavu:

```js
let state = {
  account: null
};
```

**Preƒço na tejto zmene z√°le≈æ√≠:**
- **Centralizuje** v≈°etky √∫daje aplik√°cie na jednom mieste
- **Pripravuje** ≈°trukt√∫ru na pridanie ƒèal≈°√≠ch vlastnost√≠ stavu nesk√¥r
- **Vytv√°ra** jasn√∫ hranicu medzi stavom a ostatn√Ωmi premenn√Ωmi
- **Zav√°dza** vzor, ktor√Ω sa ≈°k√°luje s rastom va≈°ej aplik√°cie

**Krok 2: Aktualiz√°cia vzorov pr√≠stupu k stavu**

Aktualizujte svoje funkcie tak, aby pou≈æ√≠vali nov√∫ ≈°trukt√∫ru stavu:

**Vo funkci√°ch `register()` a `login()` nahraƒète:**
```js
account = ...
```

T√Ωmto:
```js
state.account = ...
```

**Vo funkcii `updateDashboard()` pridajte tento riadok na zaƒçiatok:**
```js
const account = state.account;
```

**ƒåo tieto aktualiz√°cie dosahuj√∫:**
- **Zachov√°vaj√∫** existuj√∫cu funkcionalitu pri zlep≈°ovan√≠ ≈°trukt√∫ry
- **Pripravuj√∫** v√°≈° k√≥d na sofistikovanej≈°iu spr√°vu stavu
- **Vytv√°raj√∫** konzistentn√© vzory pre pr√≠stup k √∫dajom stavu
- **Zav√°dzaj√∫** z√°klad pre centralizovan√© aktualiz√°cie stavu

> üí° **Pozn√°mka**: T√°to refaktoriz√°cia okam≈æite nevyrie≈°i na≈°e probl√©my, ale vytv√°ra z√°klad pre siln√© vylep≈°enia, ktor√© pr√≠du nesk√¥r!

## Implement√°cia kontrolovan√Ωch aktualiz√°ci√≠ stavu

S na≈°√≠m stavom centralizovan√Ωm je ƒèal≈°√≠m krokom zavedenie kontrolovan√Ωch mechanizmov na √∫pravu √∫dajov. Tento pr√≠stup zabezpeƒçuje predv√≠dateƒæn√© zmeny stavu a jednoduch≈°ie ladenie.

Z√°kladn√Ω princ√≠p pripom√≠na riadenie leteckej dopravy: namiesto toho, aby sme umo≈ænili viacer√Ωm funkci√°m nez√°visle upravova≈• stav, budeme v≈°etky zmeny smerova≈• cez jednu kontrolovan√∫ funkciu. Tento vzor poskytuje jasn√Ω prehƒæad o tom, kedy a ako doch√°dza k zmen√°m √∫dajov.

**Spr√°va nemenn√©ho stavu:**

Budeme zaobch√°dza≈• s na≈°√≠m objektom `state` ako s [*nemenn√Ωm*](https://en.wikipedia.org/wiki/Immutable_object), ƒço znamen√°, ≈æe ho nikdy neupravujeme priamo. Namiesto toho ka≈æd√° zmena vytvor√≠ nov√Ω objekt stavu s aktualizovan√Ωmi √∫dajmi.

Aj keƒè sa tento pr√≠stup m√¥≈æe na prv√Ω pohƒæad zda≈• menej efekt√≠vny v porovnan√≠ s priamymi √∫pravami, poskytuje v√Ωznamn√© v√Ωhody pre ladenie, testovanie a udr≈æiavanie predv√≠dateƒænosti aplik√°cie.

**V√Ωhody spr√°vy nemenn√©ho stavu:**

| V√Ωhoda | Popis | Dopad |
|--------|-------|-------|
| **Predv√≠dateƒænos≈•** | Zmeny sa dej√∫ len cez kontrolovan√© funkcie | Jednoduch≈°ie ladenie a testovanie |
| **Sledovanie hist√≥rie** | Ka≈æd√° zmena stavu vytv√°ra nov√Ω objekt | Umo≈æ≈àuje funkciu undo/redo |
| **Prevencia vedƒæaj≈°√≠ch √∫ƒçinkov** | ≈Ωiadne n√°hodn√© √∫pravy | Predch√°dza z√°hadn√Ωm chyb√°m |
| **Optimaliz√°cia v√Ωkonu** | Jednoduch√© zistenie, kedy sa stav skutoƒçne zmenil | Umo≈æ≈àuje efekt√≠vne aktualiz√°cie UI |

**Nemennos≈• v JavaScripte pomocou `Object.freeze()`:**

JavaScript poskytuje [`Object.freeze()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) na zabr√°nenie √∫prav objektov:

```js
const immutableState = Object.freeze({ account: userData });
// Any attempt to modify immutableState will throw an error
```

**ƒåo sa tu deje:**
- **Zabra≈àuje** priamym priradeniam alebo mazaniu vlastnost√≠
- **Vyvol√°va** v√Ωnimky, ak sa pok√∫site o √∫pravy
- **Zabezpeƒçuje**, ≈æe zmeny stavu musia prejs≈• cez kontrolovan√© funkcie
- **Vytv√°ra** jasn√Ω kontrakt pre sp√¥sob, ak√Ωm sa stav m√¥≈æe aktualizova≈•

> üí° **Hlb≈°√≠ pohƒæad**: Zistite rozdiel medzi *povrchn√Ωmi* a *hlbok√Ωmi* nemenn√Ωmi objektmi v [dokument√°cii MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#What_is_shallow_freeze). Pochopenie tohto rozdielu je kƒæ√∫ƒçov√© pre komplexn√© ≈°trukt√∫ry stavu.

### √öloha

Vytvorme nov√∫ funkciu `updateState()`:

```js
function updateState(property, newData) {
  state = Object.freeze({
    ...state,
    [property]: newData
  });
}
```

V tejto funkcii vytv√°rame nov√Ω objekt stavu a kop√≠rujeme √∫daje z predch√°dzaj√∫ceho stavu pomocou [*spread (`...`) oper√°tora*](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals). Potom prep√≠≈°eme konkr√©tnu vlastnos≈• objektu stavu nov√Ωmi √∫dajmi pomocou [not√°cie hranat√Ωch z√°tvoriek](https://developer.mozilla.org/docs/Web/JavaScript/Guide/Working_with_Objects#Objects_and_properties) `[property]` na priradenie. Nakoniec zamkneme objekt, aby sme zabr√°nili √∫prav√°m pomocou `Object.freeze()`. Moment√°lne m√°me v stave ulo≈æen√∫ iba vlastnos≈• `account`, ale s t√Ωmto pr√≠stupom m√¥≈æete do stavu prida≈• toƒæko vlastnost√≠, koƒæko potrebujete.

Aktualizujeme aj inicializ√°ciu `state`, aby sme sa uistili, ≈æe poƒçiatoƒçn√Ω stav je tie≈æ zamrznut√Ω:

```js
let state = Object.freeze({
  account: null
});
```

Potom aktualizujte funkciu `register` nahraden√≠m priradenia `state.account = result;`:

```js
updateState('account', result);
```

Urobte to ist√© s funkciou `login`, nahraƒète `state.account = data;`:

```js
updateState('account', data);
```

Teraz vyu≈æijeme pr√≠le≈æitos≈• na opravu probl√©mu, ≈æe √∫daje o √∫ƒçte sa nevyma≈æ√∫, keƒè pou≈æ√≠vateƒæ klikne na *Odhl√°si≈•*.

Vytvorte nov√∫ funkciu `logout()`:

```js
function logout() {
  updateState('account', null);
  navigate('/login');
}
```

V `updateDashboard()` nahraƒète presmerovanie `return navigate('/login');` za `return logout();`;

Sk√∫ste zaregistrova≈• nov√Ω √∫ƒçet, odhl√°si≈• sa a znovu prihl√°si≈•, aby ste skontrolovali, ≈æe v≈°etko st√°le funguje spr√°vne.

> Tip: m√¥≈æete si pozrie≈• v≈°etky zmeny stavu pridan√≠m `console.log(state)` na koniec `updateState()` a otvoren√≠m konzoly vo v√Ωvoj√°rskych n√°strojoch v√°≈°ho prehliadaƒça.

## Implement√°cia uchov√°vania √∫dajov

Probl√©m straty rel√°cie, ktor√Ω sme identifikovali sk√¥r, vy≈æaduje rie≈°enie uchov√°vania, ktor√© udr≈æiava pou≈æ√≠vateƒæsk√Ω stav naprieƒç rel√°ciami prehliadaƒça. To transformuje na≈°u aplik√°ciu z doƒçasn√©ho z√°≈æitku na spoƒæahliv√Ω, profesion√°lny n√°stroj.

Predstavte si, ako at√≥mov√© hodiny udr≈æiavaj√∫ presn√Ω ƒças aj poƒças v√Ωpadkov elektriny t√Ωm, ≈æe ukladaj√∫ kritick√Ω stav do nevolatilnej pam√§te. Podobne aj webov√© aplik√°cie potrebuj√∫ mechanizmy na uchov√°vanie √∫dajov, aby zachovali d√¥le≈æit√© pou≈æ√≠vateƒæsk√© √∫daje naprieƒç rel√°ciami prehliadaƒça a obnoveniami str√°nky.

**Strategick√© ot√°zky pre uchov√°vanie √∫dajov:**

Pred implement√°ciou uchov√°vania zv√°≈æte tieto kritick√© faktory:

| Ot√°zka | Kontext bankovej aplik√°cie | Dopad rozhodnutia |
|--------|-----------------------------|-------------------|
| **S√∫ √∫daje citliv√©?** | Zostatok na √∫ƒçte, hist√≥ria transakci√≠ | V√Ωber bezpeƒçn√Ωch met√≥d uchov√°vania |
| **Ako dlho by mali √∫daje pretrv√°va≈•?** | Stav prihl√°senia vs. doƒçasn√© preferencie UI | V√Ωber vhodnej dƒ∫≈æky uchov√°vania |
| **Potrebuj√∫ √∫daje server?** | Autentifikaƒçn√© tokeny vs. nastavenia UI | Urƒçenie po≈æiadaviek na zdieƒæanie |

**Mo≈ænosti uchov√°vania v prehliadaƒçi:**

Modern√© prehliadaƒçe poskytuj√∫ niekoƒæko mechanizmov uchov√°vania, ka≈æd√Ω navrhnut√Ω pre r√¥zne pr√≠pady pou≈æitia:

**Prim√°rne API na uchov√°vanie:**

1. **[`localStorage`](https://developer.mozilla.org/docs/Web/API/Window/localStorage)**: Trval√© [Key/Value uchov√°vanie](https://en.wikipedia.org/wiki/Key%E2%80%93value_database)
   - **Uchov√°va** √∫daje naprieƒç rel√°ciami prehliadaƒça na neurƒçito  
   - **Pre≈æije** re≈°tarty prehliadaƒça a poƒç√≠taƒça
   - **Obmedzen√©** na konkr√©tnu dom√©nu webovej str√°nky
   - **Ide√°lne** pre pou≈æ√≠vateƒæsk√© preferencie a stavy prihl√°senia

2. **[`sessionStorage`](https://developer.mozilla.org/docs/Web/API/Window/sessionStorage)**: Doƒçasn√© uchov√°vanie rel√°cie
   - **Funguje** identicky
> üí° **Pokroƒçil√° mo≈ænos≈•**: Pre komplexn√© offline aplik√°cie s veƒæk√Ωmi mno≈æstvami d√°t zv√°≈æte pou≈æitie [`IndexedDB` API](https://developer.mozilla.org/docs/Web/API/IndexedDB_API). Poskytuje plnohodnotn√∫ datab√°zu na strane klienta, ale vy≈æaduje zlo≈æitej≈°iu implement√°ciu.

### √öloha: Implement√°cia perzistencie pomocou localStorage

Implementujme perzistentn√© √∫lo≈æisko, aby pou≈æ√≠vatelia zostali prihl√°sen√≠, k√Ωm sa explicitne neodhl√°sia. Pou≈æijeme `localStorage` na uchov√°vanie √∫dajov o √∫ƒçte medzi rel√°ciami prehliadaƒça.

**Krok 1: Definovanie konfigur√°cie √∫lo≈æiska**

```js
const storageKey = 'savedAccount';
```

**ƒåo t√°to kon≈°tanta poskytuje:**
- **Vytv√°ra** konzistentn√Ω identifik√°tor pre na≈°e ulo≈æen√© d√°ta
- **Zabra≈àuje** preklepom v odkazoch na kƒæ√∫ƒçe √∫lo≈æiska
- **Umo≈æ≈àuje** jednoduch√∫ zmenu kƒæ√∫ƒça √∫lo≈æiska, ak je to potrebn√©
- **Dodr≈æiava** najlep≈°ie praktiky pre udr≈æiavateƒæn√Ω k√≥d

**Krok 2: Pridanie automatickej perzistencie**

Pridajte tento riadok na koniec funkcie `updateState()`:

```js
localStorage.setItem(storageKey, JSON.stringify(state.account));
```

**Rozbor toho, ƒço sa tu deje:**
- **Konvertuje** objekt √∫ƒçtu na JSON re≈•azec pre ulo≈æenie
- **Uklad√°** d√°ta pomocou n√°≈°ho konzistentn√©ho kƒæ√∫ƒça √∫lo≈æiska
- **Vykon√°va** sa automaticky v≈ædy, keƒè d√¥jde k zmene stavu
- **Zabezpeƒçuje**, ≈æe ulo≈æen√© d√°ta s√∫ v≈ædy synchronizovan√© s aktu√°lnym stavom

> üí° **V√Ωhoda architekt√∫ry**: Keƒè≈æe sme centralizovali v≈°etky aktualiz√°cie stavu cez `updateState()`, pridanie perzistencie si vy≈æadovalo iba jeden riadok k√≥du. To demon≈°truje silu dobr√Ωch architektonick√Ωch rozhodnut√≠!

**Krok 3: Obnovenie stavu pri naƒç√≠tan√≠ aplik√°cie**

Vytvorte inicializaƒçn√∫ funkciu na obnovenie ulo≈æen√Ωch d√°t:

```js
function init() {
  const savedAccount = localStorage.getItem(storageKey);
  if (savedAccount) {
    updateState('account', JSON.parse(savedAccount));
  }

  // Our previous initialization code
  window.onpopstate = () => updateRoute();
  updateRoute();
}

init();
```

**Pochopenie procesu inicializ√°cie:**
- **Naƒç√≠ta** ak√©koƒævek predt√Ωm ulo≈æen√© √∫daje o √∫ƒçte z localStorage
- **Parsuje** JSON re≈•azec sp√§≈• na JavaScript objekt
- **Aktualizuje** stav pomocou na≈°ej kontrolovanej aktualizaƒçnej funkcie
- **Automaticky obnovuje** rel√°ciu pou≈æ√≠vateƒæa pri naƒç√≠tan√≠ str√°nky
- **Vykon√°va** sa pred aktualiz√°ciou trasy, aby bol stav dostupn√Ω

**Krok 4: Optimaliz√°cia predvolenej trasy**

Aktualizujte predvolen√∫ trasu tak, aby vyu≈æ√≠vala perzistenciu:

V `updateRoute()` nahraƒète:
```js
// Replace: return navigate('/login');
return navigate('/dashboard');
```

**Preƒço t√°to zmena d√°va zmysel:**
- **Efekt√≠vne vyu≈æ√≠va** n√°≈° nov√Ω syst√©m perzistencie
- **Umo≈æ≈àuje** dashboardu spracova≈• overenie autentifik√°cie
- **Automaticky presmeruje** na prihl√°senie, ak neexistuje ulo≈æen√° rel√°cia
- **Vytv√°ra** plynulej≈°√≠ pou≈æ√≠vateƒæsk√Ω z√°≈æitok

**Testovanie implement√°cie:**

1. Prihl√°ste sa do svojej bankovej aplik√°cie
2. Obnovte str√°nku prehliadaƒça
3. Overte, ≈æe zostanete prihl√°sen√≠ a na dashboarde
4. Zatvorte a znova otvorte prehliadaƒç
5. Vr√°≈•te sa do aplik√°cie a potvrƒète, ≈æe ste st√°le prihl√°sen√≠

üéâ **Dosiahnut√Ω √∫spech**: √öspe≈°ne ste implementovali spr√°vu perzistentn√©ho stavu! Va≈°a aplik√°cia sa teraz spr√°va ako profesion√°lna webov√° aplik√°cia.

## Vyv√°≈æenie perzistencie a aktu√°lnosti d√°t

N√°≈° syst√©m perzistencie √∫spe≈°ne udr≈æiava pou≈æ√≠vateƒæsk√© rel√°cie, ale prin√°≈°a nov√∫ v√Ωzvu: zastaranos≈• d√°t. Keƒè viacer√≠ pou≈æ√≠vatelia alebo aplik√°cie upravuj√∫ rovnak√© serverov√© d√°ta, lok√°lne ulo≈æen√© inform√°cie sa st√°vaj√∫ neaktu√°lnymi.

T√°to situ√°cia pripom√≠na vikingsk√Ωch navig√°torov, ktor√≠ sa spoliehali na ulo≈æen√© mapy hviezd, ale potrebovali aktu√°lne pozorovania na zohƒæadnenie meniacich sa podmienok. Podobne na≈°a aplik√°cia potrebuje perzistentn√Ω stav pou≈æ√≠vateƒæa aj aktu√°lne serverov√© d√°ta.

**üß™ Objavovanie probl√©mu zastaranosti d√°t:**

1. Prihl√°ste sa na dashboard pomocou √∫ƒçtu `test`
2. Spustite tento pr√≠kaz v termin√°li na simul√°ciu transakcie z in√©ho zdroja:

```sh
curl --request POST \
     --header "Content-Type: application/json" \
     --data "{ \"date\": \"2020-07-24\", \"object\": \"Bought book\", \"amount\": -20 }" \
     http://localhost:5000/api/accounts/test/transactions
```

3. Obnovte str√°nku dashboardu v prehliadaƒçi
4. Sledujte, ƒçi vid√≠te nov√∫ transakciu

**ƒåo tento test demon≈°truje:**
- **Ukazuje**, ako sa localStorage m√¥≈æe sta≈• "zastaran√Ωm" (neaktu√°lnym)
- **Simuluje** re√°lne scen√°re, kde doch√°dza k zmene d√°t mimo va≈°ej aplik√°cie
- **Odhaƒæuje** nap√§tie medzi perzistenciou a aktu√°lnos≈•ou d√°t

**V√Ωzva zastaranosti d√°t:**

| Probl√©m | Pr√≠ƒçina | Dopad na pou≈æ√≠vateƒæa |
|---------|---------|----------------------|
| **Zastaran√© d√°ta** | localStorage sa nikdy automaticky neaktualizuje | Pou≈æ√≠vatelia vidia neaktu√°lne inform√°cie |
| **Zmeny na serveri** | In√© aplik√°cie/pou≈æ√≠vatelia upravuj√∫ rovnak√© d√°ta | Nekonzistentn√© zobrazenia naprieƒç platformami |
| **Cache vs. realita** | Lok√°lna cache nezodpoved√° stavu servera | Zl√° pou≈æ√≠vateƒæsk√° sk√∫senos≈• a zm√§tok |

**Strat√©gia rie≈°enia:**

Implementujeme vzor "obnovenie pri naƒç√≠tan√≠", ktor√Ω vyv√°≈æi v√Ωhody perzistencie s potrebou aktu√°lnych d√°t. Tento pr√≠stup zachov√° plynul√Ω pou≈æ√≠vateƒæsk√Ω z√°≈æitok a z√°rove≈à zabezpeƒç√≠ presnos≈• d√°t.

### √öloha: Implement√°cia syst√©mu obnovovania d√°t

Vytvor√≠me syst√©m, ktor√Ω automaticky naƒç√≠ta aktu√°lne d√°ta zo servera a z√°rove≈à zachov√° v√Ωhody na≈°ej spr√°vy perzistentn√©ho stavu.

**Krok 1: Vytvorenie aktualiz√°tora d√°t √∫ƒçtu**

```js
async function updateAccountData() {
  const account = state.account;
  if (!account) {
    return logout();
  }

  const data = await getAccount(account.user);
  if (data.error) {
    return logout();
  }

  updateState('account', data);
}
```

**Pochopenie logiky tejto funkcie:**
- **Kontroluje**, ƒçi je pou≈æ√≠vateƒæ aktu√°lne prihl√°sen√Ω (existuje state.account)
- **Presmeruje** na odhl√°senie, ak neexistuje platn√° rel√°cia
- **Naƒç√≠ta** aktu√°lne d√°ta √∫ƒçtu zo servera pomocou existuj√∫cej funkcie `getAccount()`
- **Spracov√°va** chyby servera elegantne odhl√°sen√≠m neplatn√Ωch rel√°ci√≠
- **Aktualizuje** stav s aktu√°lnymi d√°tami pomocou na≈°ej kontrolovanej aktualizaƒçnej funkcie
- **Sp√∫≈°≈•a** automatick√∫ perzistenciu localStorage cez funkciu `updateState()`

**Krok 2: Vytvorenie obsluhy obnovovania dashboardu**

```js
async function refresh() {
  await updateAccountData();
  updateDashboard();
}
```

**ƒåo t√°to funkcia obnovovania dosahuje:**
- **Koordinuje** proces obnovovania d√°t a aktualiz√°cie UI
- **ƒåak√°**, k√Ωm sa naƒç√≠taj√∫ aktu√°lne d√°ta, pred aktualiz√°ciou zobrazenia
- **Zabezpeƒçuje**, ≈æe dashboard zobrazuje najaktu√°lnej≈°ie inform√°cie
- **Udr≈æuje** ƒçist√© oddelenie medzi spr√°vou d√°t a aktualiz√°ciou UI

**Krok 3: Integr√°cia so syst√©mom tr√°s**

Aktualizujte konfigur√°ciu tr√°s tak, aby sa automaticky sp√∫≈°≈•alo obnovovanie:

```js
const routes = {
  '/login': { templateId: 'login' },
  '/dashboard': { templateId: 'dashboard', init: refresh }
};
```

**Ako t√°to integr√°cia funguje:**
- **Sp√∫≈°≈•a** funkciu obnovovania v≈ædy, keƒè sa naƒç√≠ta trasa dashboardu
- **Zabezpeƒçuje**, ≈æe aktu√°lne d√°ta s√∫ v≈ædy zobrazen√©, keƒè pou≈æ√≠vatelia prejd√∫ na dashboard
- **Udr≈æuje** existuj√∫cu ≈°trukt√∫ru tr√°s a z√°rove≈à prid√°va aktu√°lnos≈• d√°t
- **Poskytuje** konzistentn√Ω vzor pre inicializ√°ciu ≈°pecifick√∫ pre trasy

**Testovanie syst√©mu obnovovania d√°t:**

1. Prihl√°ste sa do svojej bankovej aplik√°cie
2. Spustite curl pr√≠kaz z predch√°dzaj√∫ceho kroku na vytvorenie novej transakcie
3. Obnovte str√°nku dashboardu alebo prejdite na in√∫ str√°nku a sp√§≈•
4. Overte, ≈æe nov√° transakcia sa okam≈æite zobraz√≠

üéâ **Dokonal√° rovnov√°ha dosiahnut√°**: Va≈°a aplik√°cia teraz kombinuje plynul√Ω z√°≈æitok z perzistentn√©ho stavu s presnos≈•ou aktu√°lnych serverov√Ωch d√°t!

## V√Ωzva GitHub Copilot Agent üöÄ

Pou≈æite re≈æim Agent na splnenie nasleduj√∫cej v√Ωzvy:

**Popis:** Implementujte komplexn√Ω syst√©m spr√°vy stavu s funkciami undo/redo pre bankov√∫ aplik√°ciu. T√°to v√Ωzva v√°m pom√¥≈æe precviƒçi≈• pokroƒçil√© koncepty spr√°vy stavu vr√°tane sledovania hist√≥rie stavu, nemenn√Ωch aktualiz√°ci√≠ a synchroniz√°cie pou≈æ√≠vateƒæsk√©ho rozhrania.

**Zadanie:** Vytvorte roz≈°√≠ren√Ω syst√©m spr√°vy stavu, ktor√Ω zah≈ï≈àa: 1) Pole hist√≥rie stavu, ktor√© sleduje v≈°etky predch√°dzaj√∫ce stavy, 2) Funkcie undo a redo, ktor√© umo≈æ≈àuj√∫ n√°vrat k predch√°dzaj√∫cim stavom, 3) Tlaƒçidl√° UI pre oper√°cie undo/redo na dashboarde, 4) Maxim√°lny limit hist√≥rie 10 stavov na predch√°dzanie probl√©mom s pam√§≈•ou, a 5) Spr√°vne vyƒçistenie hist√≥rie pri odhl√°sen√≠ pou≈æ√≠vateƒæa. Zabezpeƒçte, aby funkcie undo/redo fungovali so zmenami zostatku na √∫ƒçte a perzistovali medzi obnoveniami prehliadaƒça.

Viac o [re≈æime agent](https://code.visualstudio.com/blogs/2025/02/24/introducing-copilot-agent-mode) sa dozviete tu.

## üöÄ V√Ωzva: Optimaliz√°cia √∫lo≈æiska

Va≈°a implement√°cia teraz efekt√≠vne spravuje pou≈æ√≠vateƒæsk√© rel√°cie, obnovovanie d√°t a spr√°vu stavu. Zv√°≈æte v≈°ak, ƒçi n√°≈° aktu√°lny pr√≠stup optim√°lne vyva≈æuje efektivitu √∫lo≈æiska s funkƒçnos≈•ou.

Rovnako ako ≈°achov√≠ majstri, ktor√≠ rozli≈°uj√∫ medzi nevyhnutn√Ωmi fig√∫rkami a t√Ωmi, ktor√© m√¥≈æu by≈• obetovan√©, efekt√≠vna spr√°va stavu vy≈æaduje identifik√°ciu d√°t, ktor√© musia by≈• perzistentn√©, oproti t√Ωm, ktor√© by mali by≈• v≈ædy aktu√°lne zo servera.

**Anal√Ωza optimaliz√°cie:**

Vyhodno≈•te svoju aktu√°lnu implement√°ciu localStorage a zv√°≈æte tieto strategick√© ot√°zky:
- Ak√© minimum inform√°ci√≠ je potrebn√© na udr≈æanie autentifik√°cie pou≈æ√≠vateƒæa?
- Ktor√© d√°ta sa menia tak ƒçasto, ≈æe lok√°lne ukladanie neprin√°≈°a veƒæk√Ω √∫≈æitok?
- Ako m√¥≈æe optimaliz√°cia √∫lo≈æiska zlep≈°i≈• v√Ωkon bez zhor≈°enia pou≈æ√≠vateƒæsk√©ho z√°≈æitku?

**Strat√©gia implement√°cie:**
- **Identifikujte** nevyhnutn√© d√°ta, ktor√© musia by≈• perzistentn√© (pravdepodobne len identifik√°cia pou≈æ√≠vateƒæa)
- **Upravte** svoju implement√°ciu localStorage tak, aby uchov√°vala iba kritick√© √∫daje o rel√°cii
- **Zabezpeƒçte**, ≈æe aktu√°lne d√°ta sa v≈ædy naƒç√≠taj√∫ zo servera pri n√°v≈°teve dashboardu
- **Otestujte**, ƒçi v√°≈° optimalizovan√Ω pr√≠stup zachov√°va rovnak√Ω pou≈æ√≠vateƒæsk√Ω z√°≈æitok

**Pokroƒçil√© √∫vahy:**
- **Porovnajte** kompromisy medzi ukladan√≠m √∫pln√Ωch √∫dajov o √∫ƒçte a iba autentifikaƒçn√Ωch tokenov
- **Zdokumentujte** svoje rozhodnutia a d√¥vody pre bud√∫cich ƒçlenov t√≠mu

T√°to v√Ωzva v√°m pom√¥≈æe myslie≈• ako profesion√°lny v√Ωvoj√°r, ktor√Ω zva≈æuje funkƒçnos≈• aj efektivitu aplik√°cie. Dajte si ƒças na experimentovanie s r√¥znymi pr√≠stupmi!

## Kv√≠z po predn√°≈°ke

[Kv√≠z po predn√°≈°ke](https://ff-quizzes.netlify.app/web/quiz/48)

## Zadanie

[Implementujte dial√≥g "Prida≈• transakciu"](assignment.md)

Tu je pr√≠klad v√Ωsledku po dokonƒçen√≠ zadania:

![Screenshot zobrazuj√∫ci pr√≠klad dial√≥gu "Prida≈• transakciu"](../../../../translated_images/dialog.93bba104afeb79f12f65ebf8f521c5d64e179c40b791c49c242cf15f7e7fab15.sk.png)

---

**Zrieknutie sa zodpovednosti**:  
Tento dokument bol prelo≈æen√Ω pomocou slu≈æby AI prekladu [Co-op Translator](https://github.com/Azure/co-op-translator). Hoci sa sna≈æ√≠me o presnos≈•, pros√≠m, berte na vedomie, ≈æe automatizovan√© preklady m√¥≈æu obsahova≈• chyby alebo nepresnosti. P√¥vodn√Ω dokument v jeho rodnom jazyku by mal by≈• pova≈æovan√Ω za autoritat√≠vny zdroj. Pre kritick√© inform√°cie sa odpor√∫ƒça profesion√°lny ƒæudsk√Ω preklad. Nie sme zodpovedn√≠ za ≈æiadne nedorozumenia alebo nespr√°vne interpret√°cie vypl√Ωvaj√∫ce z pou≈æitia tohto prekladu.