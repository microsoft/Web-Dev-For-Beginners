<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "f587e913e3f7c0b1c549a05dd74ee8e5",
  "translation_date": "2025-08-27T23:00:15+00:00",
  "source_file": "7-bank-project/3-data/README.md",
  "language_code": "sr"
}
-->
# Изградња апликације за банкарство, део 3: Методе за преузимање и коришћење података

## Квиз пре предавања

[Квиз пре предавања](https://ashy-river-0debb7803.1.azurestaticapps.net/quiz/45)

### Увод

У срцу сваке веб апликације налазе се *подаци*. Подаци могу имати различите облике, али њихова главна сврха је увек приказивање информација кориснику. Са веб апликацијама које постају све интерактивније и сложеније, начин на који корисник приступа и интерагује са информацијама сада је кључни део веб развоја.

У овој лекцији ћемо видети како да асинхроно преузмемо податке са сервера и користимо те податке за приказивање информација на веб страници без поновног учитавања HTML-а.

### Предуслови

Потребно је да сте изградили [формулар за пријаву и регистрацију](../2-forms/README.md) као део веб апликације за ову лекцију. Такође, потребно је да инсталирате [Node.js](https://nodejs.org) и [покренете серверски API](../api/README.md) локално како бисте добили податке о налогу.

Можете тестирати да ли сервер ради исправно извршавањем ове команде у терминалу:

```sh
curl http://localhost:5000/api
# -> should return "Bank API v1.0.0" as a result
```

---

## AJAX и преузимање података

Традиционалне веб странице ажурирају приказани садржај када корисник изабере линк или пошаље податке путем формулара, поновним учитавањем целе HTML странице. Сваки пут када је потребно учитати нове податке, веб сервер враћа потпуно нову HTML страницу коју прегледач мора да обради, прекидајући тренутну акцију корисника и ограничавајући интеракције током учитавања. Овај радни ток се такође назива *вишестранична апликација* или *MPA*.

![Радни ток ажурирања у вишестраничној апликацији](../../../../translated_images/mpa.7f7375a1a2d4aa779d3f928a2aaaf9ad76bcdeb05cfce2dc27ab126024050f51.sr.png)

Када су веб апликације почеле да постају сложеније и интерактивније, појавила се нова техника звана [AJAX (асинхрони JavaScript и XML)](https://en.wikipedia.org/wiki/Ajax_(programming)). Ова техника омогућава веб апликацијама да шаљу и преузимају податке са сервера асинхроно користећи JavaScript, без потребе за поновним учитавањем HTML странице, што резултира бржим ажурирањима и глаткијим интеракцијама корисника. Када се нови подаци добију са сервера, тренутна HTML страница може бити ажурирана JavaScript-ом користећи [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model) API. Временом, овај приступ је еволуирао у оно што се сада назива [*једностранична апликација* или *SPA*](https://en.wikipedia.org/wiki/Single-page_application).

![Радни ток ажурирања у једностраничној апликацији](../../../../translated_images/spa.268ec73b41f992c2a21ef9294235c6ae597b3c37e2c03f0494c2d8857325cc57.sr.png)

Када је AJAX први пут уведен, једини API доступан за асинхроно преузимање података био је [`XMLHttpRequest`](https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest). Међутим, модерни прегледачи сада имплементирају погоднији и моћнији [`Fetch` API](https://developer.mozilla.org/docs/Web/API/Fetch_API), који користи промисе и боље је прилагођен за манипулацију JSON подацима.

> Иако сви модерни прегледачи подржавају `Fetch API`, ако желите да ваша веб апликација ради на застарелим или старим прегледачима, увек је добра идеја да прво проверите [табелу компатибилности на caniuse.com](https://caniuse.com/fetch).

### Задатак

У [претходној лекцији](../2-forms/README.md) имплементирали смо формулар за регистрацију ради креирања налога. Сада ћемо додати код за пријаву користећи постојећи налог и преузимање његових података. Отворите датотеку `app.js` и додајте нову функцију `login`:

```js
async function login() {
  const loginForm = document.getElementById('loginForm')
  const user = loginForm.user.value;
}
```

Овде почињемо преузимањем елемента формулара помоћу `getElementById()`, а затим добијамо корисничко име из уноса помоћу `loginForm.user.value`. Свака контрола формулара може се приступити преко њеног имена (постављеног у HTML-у помоћу атрибута `name`) као својства формулара.

На сличан начин као што смо урадили за регистрацију, креираћемо још једну функцију за извршавање захтева серверу, али овог пута за преузимање података о налогу:

```js
async function getAccount(user) {
  try {
    const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user));
    return await response.json();
  } catch (error) {
    return { error: error.message || 'Unknown error' };
  }
}
```

Користимо `fetch` API за асинхроно захтевање података са сервера, али овог пута не требају нам додатни параметри осим URL-а који позивамо, јер само упитујемо податке. Подразумевано, `fetch` креира [`GET`](https://developer.mozilla.org/docs/Web/HTTP/Methods/GET) HTTP захтев, што је оно што нам овде треба.

✅ `encodeURIComponent()` је функција која избегава специјалне карактере за URL. Које проблеме бисмо могли имати ако не позовемо ову функцију и директно користимо вредност `user` у URL-у?

Сада ажурирамо нашу функцију `login` да користи `getAccount`:

```js
async function login() {
  const loginForm = document.getElementById('loginForm')
  const user = loginForm.user.value;
  const data = await getAccount(user);

  if (data.error) {
    return console.log('loginError', data.error);
  }

  account = data;
  navigate('/dashboard');
}
```

Прво, пошто је `getAccount` асинхрона функција, морамо је ускладити са кључном речју `await` да бисмо сачекали резултат сервера. Као и код сваког захтева серверу, морамо се носити са случајевима грешке. За сада ћемо само додати поруку у лог за приказивање грешке и вратити се на то касније.

Затим морамо да сачувамо податке негде како бисмо их касније могли користити за приказивање информација на контролној табли. Пошто променљива `account` још не постоји, креираћемо глобалну променљиву за њу на врху наше датотеке:

```js
let account = null;
```

Након што се кориснички подаци сачувају у променљивој, можемо се пребацити са странице *login* на *dashboard* користећи функцију `navigate()` коју већ имамо.

На крају, потребно је да позовемо нашу функцију `login` када се формулар за пријаву пошаље, модификовањем HTML-а:

```html
<form id="loginForm" action="javascript:login()">
```

Тестирајте да ли све ради исправно тако што ћете регистровати нови налог и покушати да се пријавите користећи исти налог.

Пре него што пређемо на следећи део, можемо такође довршити функцију `register` додавањем овога на крај функције:

```js
account = result;
navigate('/dashboard');
```

✅ Да ли сте знали да подразумевано можете позивати серверске API-је само са *истог домена и порта* као веб страница коју гледате? Ово је безбедносни механизам који прегледачи спроводе. Али чекајте, наша веб апликација ради на `localhost:3000`, док серверски API ради на `localhost:5000`, зашто функционише? Коришћењем технике зване [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/docs/Web/HTTP/CORS), могуће је извршити HTTP захтеве преко различитих порекла ако сервер дода посебне заглавља у одговор, дозвољавајући изузетке за одређене домене.

> Сазнајте више о API-јима кроз ову [лекцију](https://docs.microsoft.com/learn/modules/use-apis-discover-museum-art/?WT.mc_id=academic-77807-sagibbon)

## Ажурирање HTML-а за приказивање података

Сада када имамо корисничке податке, морамо ажурирати постојећи HTML да их прикажемо. Већ знамо како да преузмемо елемент из DOM-а, на пример користећи `document.getElementById()`. Након што имате основни елемент, ево неких API-ја које можете користити за његово модификовање или додавање дечијих елемената:

- Коришћењем својства [`textContent`](https://developer.mozilla.org/docs/Web/API/Node/textContent) можете променити текст елемента. Имајте на уму да промена ове вредности уклања све дечије елементе (ако их има) и замењује их датим текстом. Као таква, ово је такође ефикасан метод за уклањање свих дечијих елемената датог елемента додељивањем празног низа `''`.

- Коришћењем [`document.createElement()`](https://developer.mozilla.org/docs/Web/API/Document/createElement) заједно са методом [`append()`](https://developer.mozilla.org/docs/Web/API/ParentNode/append) можете креирати и додати један или више нових дечијих елемената.

✅ Коришћењем својства [`innerHTML`](https://developer.mozilla.org/docs/Web/API/Element/innerHTML) елемента могуће је променити његов HTML садржај, али ово треба избегавати јер је рањиво на [нападе преко скриптовања сајта (XSS)](https://developer.mozilla.org/docs/Glossary/Cross-site_scripting).

### Задатак

Пре него што пређемо на екран контролне табле, постоји још једна ствар коју треба да урадимо на страници *login*. Тренутно, ако покушате да се пријавите са корисничким именом које не постоји, порука се приказује у конзоли, али за обичног корисника ништа се не мења и не знате шта се дешава.

Додајмо елемент за резервисано место у формулару за пријаву где можемо приказати поруку о грешци ако је потребно. Добро место би било непосредно пре дугмета за пријаву `<button>`:

```html
...
<div id="loginError"></div>
<button>Login</button>
...
```

Овај `<div>` елемент је празан, што значи да ништа неће бити приказано на екрану док му не додамо садржај. Такође му дајемо `id` како бисмо га лако могли преузети помоћу JavaScript-а.

Вратите се у датотеку `app.js` и креирајте нову помоћну функцију `updateElement`:

```js
function updateElement(id, text) {
  const element = document.getElementById(id);
  element.textContent = text;
}
```

Ова функција је прилично једноставна: датом *id*-у елемента и *тексту*, ажурираће текстуални садржај DOM елемента са одговарајућим `id`. Користимо ову методу уместо претходне поруке о грешци у функцији `login`:

```js
if (data.error) {
  return updateElement('loginError', data.error);
}
```

Сада, ако покушате да се пријавите са неважећим налогом, требало би да видите нешто овако:

![Снимак екрана који приказује поруку о грешци током пријаве](../../../../translated_images/login-error.416fe019b36a63276764c2349df5d99e04ebda54fefe60c715ee87a28d5d4ad0.sr.png)

Сада имамо текст грешке који се визуелно приказује, али ако га пробате са читачем екрана, приметићете да ништа није најављено. Да би текст који се динамички додаје на страницу био најављен од стране читача екрана, потребно је да користи нешто што се зове [Live Region](https://developer.mozilla.org/docs/Web/Accessibility/ARIA/ARIA_Live_Regions). Овде ћемо користити специфичан тип live региона који се зове alert:

```html
<div id="loginError" role="alert"></div>
```

Имплементирајте исто понашање за грешке у функцији `register` (не заборавите да ажурирате HTML).

## Приказивање информација на контролној табли

Користећи исте технике које смо управо видели, такође ћемо се побринути за приказивање информација о налогу на страници контролне табле.

Овако изгледа објекат налога добијен са сервера:

```json
{
  "user": "test",
  "currency": "$",
  "description": "Test account",
  "balance": 75,
  "transactions": [
    { "id": "1", "date": "2020-10-01", "object": "Pocket money", "amount": 50 },
    { "id": "2", "date": "2020-10-03", "object": "Book", "amount": -10 },
    { "id": "3", "date": "2020-10-04", "object": "Sandwich", "amount": -5 }
  ],
}
```

> Напомена: да бисте себи олакшали, можете користити већ постојећи налог `test` који је већ попуњен подацима.

### Задатак

Почнимо заменом секције "Balance" у HTML-у додавањем елемената за резервисано место:

```html
<section>
  Balance: <span id="balance"></span><span id="currency"></span>
</section>
```

Такође ћемо додати нову секцију одмах испод за приказивање описа налога:

```html
<h2 id="description"></h2>
```

✅ Пошто опис налога функционише као наслов за садржај испод њега, означен је семантички као заглавље. Сазнајте више о томе како је [структура заглавља](https://www.nomensa.com/blog/2017/how-structure-headings-web-accessibility) важна за приступачност и критички погледајте страницу да бисте утврдили шта још може бити заглавље.

Затим ћемо креирати нову функцију у `app.js` за попуњавање резервисаног места:

```js
function updateDashboard() {
  if (!account) {
    return navigate('/login');
  }

  updateElement('description', account.description);
  updateElement('balance', account.balance.toFixed(2));
  updateElement('currency', account.currency);
}
```

Прво, проверавамо да ли имамо податке о налогу који су нам потребни пре него што наставимо даље. Затим користимо функцију `updateElement()` коју смо раније креирали за ажурирање HTML-а.

> Да би приказивање стања било лепше, користимо методу [`toFixed(2)`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) да бисмо приморали приказивање вредности са 2 цифре након децималне тачке.

Сада треба да позовемо нашу функцију `updateDashboard()` сваки пут када се учита страница контролне табле. Ако сте већ завршили [задатак из лекције 1](../1-template-route/assignment.md), ово би требало да буде једноставно, иначе можете користити следећу имплементацију.

Додајте овај код на крај функције `updateRoute()`:

```js
if (typeof route.init === 'function') {
  route.init();
}
```

И ажурирајте дефиницију рута са:

```js
const routes = {
  '/login': { templateId: 'login' },
  '/dashboard': { templateId: 'dashboard', init: updateDashboard }
};
```

Са овом променом, сваки пут када се прикаже страница контролне табле, позива се функција `updateDashboard()`. Након пријаве, требало би да можете да видите стање налога, валуту и опис.

## Динамичко креирање редова табеле помоћу HTML шаблона

У [првој лекцији](../1-template-route/README.md) користили смо HTML шаблоне заједно са методом [`appendChild()`](https://developer.mozilla.org/docs/Web/API/Node/appendChild) за имплементацију навигације у нашој апликацији. Шаблони могу бити и мањи и користити се за динамичко попуњавање поновљених делова странице.

Користићемо сличан приступ за приказивање листе трансакција у HTML табели.

### Задатак

Додајте нови шаблон у HTML `<body>`:

```html
<template id="transaction">
  <tr>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</template>
```

Овај шаблон представља један ред табеле, са 3 колоне које желимо да попунимо: *датум*, *објекат* и *износ* трансакције.

Затим, додајте овај `id` атрибут у `<tbody>` елемент табеле унутар шаблона контролне табле како би га било лакше пронаћи помоћу JavaScript-а:

```html
<tbody id="transactions"></tbody>
```

Наш HTML је спреман, прелазимо на JavaScript код и креирамо нову функцију `createTransactionRow`:

```js
function createTransactionRow(transaction) {
  const template = document.getElementById('transaction');
  const transactionRow = template.content.cloneNode(true);
  const tr = transactionRow.querySelector('tr');
  tr.children[0].textContent = transaction.date;
  tr.children[1].textContent = transaction.object;
  tr.children[2].textContent = transaction.amount.toFixed(2);
  return transactionRow;
}
```

Ова функција ради управо оно што њено име имплицира: користећи шаблон који смо раније креирали, креира нови ред табеле и попуњава његов садржај користећи податке о трансакцији. Користићемо ово у нашој функцији `updateDashboard()` за попуњавање табеле:

```js
const transactionsRows = document.createDocumentFragment();
for (const transaction of account.transactions) {
  const transactionRow = createTransactionRow(transaction);
  transactionsRows.appendChild(transactionRow);
}
updateElement('transactions', transactionsRows);
```

Овде користимо методу [`document.createDocumentFragment()`](https://developer.mozilla.org/docs/Web/API/Document/createDocumentFragment
Ако покушате да се пријавите користећи налог `test`, сада би требало да видите листу трансакција на контролној табли 🎉.

---

## 🚀 Изазов

Радите заједно како бисте страницу контролне табле учинили да изгледа као права апликација за банкарство. Ако сте већ стилизовали своју апликацију, покушајте да користите [media queries](https://developer.mozilla.org/docs/Web/CSS/Media_Queries) за креирање [респонзивног дизајна](https://developer.mozilla.org/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks) који добро функционише и на десктоп и на мобилним уређајима.

Ево примера стилизоване странице контролне табле:

![Снимак екрана пример резултата контролне табле након стилизовања](../../../../translated_images/screen2.123c82a831a1d14ab2061994be2fa5de9cec1ce651047217d326d4773a6348e4.sr.png)

## Квиз након предавања

[Квиз након предавања](https://ashy-river-0debb7803.1.azurestaticapps.net/quiz/46)

## Задатак

[Рефакторишите и коментаришите свој код](assignment.md)

---

**Одрицање од одговорности**:  
Овај документ је преведен коришћењем услуге за превођење помоћу вештачке интелигенције [Co-op Translator](https://github.com/Azure/co-op-translator). Иако се трудимо да обезбедимо тачност, имајте у виду да аутоматски преводи могу садржати грешке или нетачности. Оригинални документ на изворном језику треба сматрати ауторитативним извором. За критичне информације препоручује се професионални превод од стране људи. Не сносимо одговорност за било каква погрешна тумачења или неспоразуме који могу произаћи из коришћења овог превода.