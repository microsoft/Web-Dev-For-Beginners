<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "b46acf79da8550d76445eed00b06c878",
  "translation_date": "2025-10-03T13:20:54+00:00",
  "source_file": "7-bank-project/4-state-management/README.md",
  "language_code": "uk"
}
-->
# Створення банківського додатка, частина 4: Концепції управління станом

## Передлекційна вікторина

[Передлекційна вікторина](https://ff-quizzes.netlify.app/web/quiz/47)

### Вступ

Зі зростанням веб-додатка стає складніше відстежувати всі потоки даних. Який код отримує дані, яка сторінка їх використовує, де і коли їх потрібно оновлювати... Легко опинитися з заплутаним кодом, який важко підтримувати. Це особливо актуально, коли потрібно ділитися даними між різними сторінками додатка, наприклад, даними користувача. Концепція *управління станом* завжди існувала у всіх типах програм, але зі зростанням складності веб-додатків це стало ключовим моментом, який варто враховувати під час розробки.

У цій фінальній частині ми переглянемо додаток, який ми створили, щоб переосмислити, як управляється стан, забезпечуючи підтримку оновлення браузера в будь-який момент і збереження даних між сеансами користувача.

### Передумови

Вам потрібно завершити частину [отримання даних](../3-data/README.md) веб-додатка для цього уроку. Також необхідно встановити [Node.js](https://nodejs.org) і [запустити сервер API](../api/README.md) локально, щоб ви могли керувати даними облікового запису.

Ви можете перевірити, чи сервер працює належним чином, виконавши цю команду в терміналі:

```sh
curl http://localhost:5000/api
# -> should return "Bank API v1.0.0" as a result
```

---

## Переосмислення управління станом

У [попередньому уроці](../3-data/README.md) ми ввели базове поняття стану в нашому додатку за допомогою глобальної змінної `account`, яка містить банківські дані для поточного користувача. Однак наша поточна реалізація має деякі недоліки. Спробуйте оновити сторінку, коли ви на інформаційній панелі. Що відбувається?

Є три проблеми з поточним кодом:

- Стан не зберігається, оскільки оновлення браузера повертає вас на сторінку входу.
- Є кілька функцій, які змінюють стан. У міру зростання додатка це може ускладнити відстеження змін, і легко забути оновити одну з них.
- Стан не очищається, тому коли ви натискаєте *Вийти*, дані облікового запису все ще залишаються, навіть якщо ви на сторінці входу.

Ми могли б оновити наш код, щоб вирішити ці проблеми по одному, але це створило б більше дублювання коду і зробило б додаток складнішим для підтримки. Або ми могли б зупинитися на кілька хвилин і переосмислити нашу стратегію.

> Які проблеми ми насправді намагаємося вирішити?

[Управління станом](https://uk.wikipedia.org/wiki/Управління_станом) полягає у знаходженні хорошого підходу для вирішення цих двох конкретних проблем:

- Як зробити потоки даних у додатку зрозумілими?
- Як забезпечити, щоб дані стану завжди були синхронізовані з інтерфейсом користувача (і навпаки)?

Як тільки ви вирішите ці питання, будь-які інші проблеми, які можуть виникнути, або вже будуть вирішені, або стануть легшими для вирішення. Є багато можливих підходів для вирішення цих проблем, але ми оберемо поширене рішення, яке полягає у **централізації даних і способів їх зміни**. Потоки даних виглядатимуть так:

![Схема, що показує потоки даних між HTML, діями користувача та станом](../../../../translated_images/data-flow.fa2354e0908fecc89b488010dedf4871418a992edffa17e73441d257add18da4.uk.png)

> Ми не будемо тут розглядати частину, де дані автоматично оновлюють вигляд, оскільки це пов'язано з більш складними концепціями [Реактивного програмування](https://uk.wikipedia.org/wiki/Реактивне_програмування). Це гарна тема для подальшого вивчення, якщо ви готові до глибшого занурення.

✅ Існує багато бібліотек з різними підходами до управління станом, [Redux](https://redux.js.org) є популярним варіантом. Ознайомтеся з концепціями та шаблонами, які використовуються, оскільки це часто хороший спосіб дізнатися, з якими потенційними проблемами ви можете зіткнутися у великих веб-додатках і як їх можна вирішити.

### Завдання

Почнемо з невеликого рефакторингу. Замініть оголошення `account`:

```js
let account = null;
```

На:

```js
let state = {
  account: null
};
```

Ідея полягає в тому, щоб *централізувати* всі дані нашого додатка в одному об'єкті стану. Зараз у нас є лише `account` у стані, тому це не змінює багато, але створює основу для подальших змін.

Також потрібно оновити функції, які його використовують. У функціях `register()` і `login()` замініть `account = ...` на `state.account = ...`;

На початку функції `updateDashboard()` додайте цей рядок:

```js
const account = state.account;
```

Цей рефакторинг сам по собі не приніс великих покращень, але ідея полягала в тому, щоб закласти основу для наступних змін.

## Відстеження змін даних

Тепер, коли ми створили об'єкт `state` для зберігання наших даних, наступним кроком є централізація оновлень. Мета полягає в тому, щоб полегшити відстеження будь-яких змін і моментів, коли вони відбуваються.

Щоб уникнути змін об'єкта `state`, також є гарною практикою вважати його [*незмінним*](https://uk.wikipedia.org/wiki/Незмінний_об'єкт), тобто таким, що не може бути змінений взагалі. Це також означає, що вам потрібно створити новий об'єкт стану, якщо ви хочете щось у ньому змінити. Таким чином, ви захищаєтеся від потенційно небажаних [побічних ефектів](https://uk.wikipedia.org/wiki/Побічний_ефект_(інформатика)) і відкриваєте можливості для нових функцій у вашому додатку, таких як реалізація скасування/повтору, а також спрощуєте налагодження. Наприклад, ви могли б реєструвати кожну зміну стану і зберігати історію змін, щоб зрозуміти джерело помилки.

У JavaScript ви можете використовувати [`Object.freeze()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze), щоб створити незмінну версію об'єкта. Якщо ви спробуєте внести зміни до незмінного об'єкта, буде викликано виняток.

✅ Чи знаєте ви різницю між *поверхневим* і *глибоким* незмінним об'єктом? Ви можете прочитати про це [тут](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#What_is_shallow_freeze).

### Завдання

Давайте створимо нову функцію `updateState()`:

```js
function updateState(property, newData) {
  state = Object.freeze({
    ...state,
    [property]: newData
  });
}
```

У цій функції ми створюємо новий об'єкт стану і копіюємо дані з попереднього стану за допомогою [*оператора розпакування (`...`)*](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals). Потім ми перевизначаємо певну властивість об'єкта стану новими даними, використовуючи [нотацію з квадратними дужками](https://developer.mozilla.org/docs/Web/JavaScript/Guide/Working_with_Objects#Objects_and_properties) `[property]` для присвоєння. Нарешті, ми блокуємо об'єкт, щоб запобігти модифікаціям, використовуючи `Object.freeze()`. Зараз у нас є лише властивість `account`, збережена в стані, але з цим підходом ви можете додати стільки властивостей, скільки потрібно.

Ми також оновимо ініціалізацію `state`, щоб переконатися, що початковий стан також заморожений:

```js
let state = Object.freeze({
  account: null
});
```

Після цього оновіть функцію `register`, замінивши присвоєння `state.account = result;` на:

```js
updateState('account', result);
```

Те ж саме зробіть із функцією `login`, замінивши `state.account = data;` на:

```js
updateState('account', data);
```

Тепер скористаємося можливістю виправити проблему з тим, що дані облікового запису не очищаються, коли користувач натискає *Вийти*.

Створіть нову функцію `logout()`:

```js
function logout() {
  updateState('account', null);
  navigate('/login');
}
```

У `updateDashboard()` замініть перенаправлення `return navigate('/login');` на `return logout();`

Спробуйте зареєструвати новий обліковий запис, вийти і знову увійти, щоб переконатися, що все працює правильно.

> Порада: ви можете переглянути всі зміни стану, додавши `console.log(state)` в кінці `updateState()` і відкривши консоль у засобах розробника вашого браузера.

## Збереження стану

Більшість веб-додатків потребують збереження даних для коректної роботи. Усі критичні дані зазвичай зберігаються в базі даних і доступні через серверний API, як у нашому випадку з даними облікового запису користувача. Але іноді також цікаво зберігати деякі дані на клієнтському додатку, який працює у вашому браузері, для кращого користувацького досвіду або для покращення продуктивності завантаження.

Коли ви хочете зберігати дані у вашому браузері, є кілька важливих питань, які варто задати:

- *Чи є дані конфіденційними?* Ви повинні уникати зберігання будь-яких конфіденційних даних на клієнті, таких як паролі користувачів.
- *Як довго вам потрібно зберігати ці дані?* Ви плануєте отримувати доступ до цих даних лише під час поточного сеансу чи хочете, щоб вони зберігалися назавжди?

Існує кілька способів зберігання інформації у веб-додатку, залежно від того, чого ви хочете досягти. Наприклад, ви можете використовувати URL-адреси для зберігання пошукового запиту і зробити його доступним для інших користувачів. Ви також можете використовувати [HTTP cookies](https://developer.mozilla.org/docs/Web/HTTP/Cookies), якщо дані потрібно передавати на сервер, наприклад, інформацію для [автентифікації](https://uk.wikipedia.org/wiki/Автентифікація).

Інший варіант — використовувати один із багатьох API браузера для зберігання даних. Два з них є особливо цікавими:

- [`localStorage`](https://developer.mozilla.org/docs/Web/API/Window/localStorage): [Сховище ключ/значення](https://uk.wikipedia.org/wiki/База_даних_ключ-значення), яке дозволяє зберігати дані, специфічні для поточного веб-сайту, між різними сеансами. Збережені дані ніколи не закінчуються.
- [`sessionStorage`](https://developer.mozilla.org/docs/Web/API/Window/sessionStorage): працює так само, як `localStorage`, за винятком того, що дані, збережені в ньому, очищаються після завершення сеансу (коли браузер закривається).

Зверніть увагу, що обидва ці API дозволяють зберігати лише [рядки](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String). Якщо ви хочете зберігати складні об'єкти, вам потрібно буде серіалізувати їх у формат [JSON](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/JSON) за допомогою [`JSON.stringify()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).

✅ Якщо ви хочете створити веб-додаток, який не працює з сервером, також можливо створити базу даних на клієнті, використовуючи [`IndexedDB` API](https://developer.mozilla.org/docs/Web/API/IndexedDB_API). Цей варіант зарезервований для складних випадків використання або якщо вам потрібно зберігати значну кількість даних, оскільки він складніший у використанні.

### Завдання

Ми хочемо, щоб наші користувачі залишалися в системі, поки вони явно не натиснуть кнопку *Вийти*, тому ми будемо використовувати `localStorage` для зберігання даних облікового запису. Спочатку визначимо ключ, який ми будемо використовувати для зберігання наших даних.

```js
const storageKey = 'savedAccount';
```

Потім додайте цей рядок у кінець функції `updateState()`:

```js
localStorage.setItem(storageKey, JSON.stringify(state.account));
```

Таким чином, дані облікового запису користувача будуть збережені і завжди актуальні, оскільки ми централізували всі оновлення стану. Це той момент, коли ми починаємо отримувати вигоду від усіх наших попередніх рефакторингів 🙂.

Оскільки дані зберігаються, ми також повинні подбати про їх відновлення під час завантаження додатка. Оскільки у нас починає з'являтися більше коду ініціалізації, можливо, варто створити нову функцію `init`, яка також включає наш попередній код у кінці `app.js`:

```js
function init() {
  const savedAccount = localStorage.getItem(storageKey);
  if (savedAccount) {
    updateState('account', JSON.parse(savedAccount));
  }

  // Our previous initialization code
  window.onpopstate = () => updateRoute();
  updateRoute();
}

init();
```

Тут ми отримуємо збережені дані, і якщо вони є, оновлюємо стан відповідно. Важливо зробити це *до* оновлення маршруту, оскільки під час оновлення сторінки може бути код, який залежить від стану.

Ми також можемо зробити сторінку *Dashboard* сторінкою за замовчуванням нашого додатка, оскільки тепер ми зберігаємо дані облікового запису. Якщо дані не знайдені, інформаційна панель все одно перенаправляє на сторінку *Login*. У `updateRoute()` замініть резервний варіант `return navigate('/login');` на `return navigate('/dashboard');`.

Тепер увійдіть у додаток і спробуйте оновити сторінку. Ви повинні залишитися на інформаційній панелі. З цим оновленням ми вирішили всі наші початкові проблеми...

## Оновлення даних

...Але ми могли також створити нову проблему. Ой!

Перейдіть на інформаційну панель, використовуючи обліковий запис `test`, потім виконайте цю команду в терміналі, щоб створити нову транзакцію:

```sh
curl --request POST \
     --header "Content-Type: application/json" \
     --data "{ \"date\": \"2020-07-24\", \"object\": \"Bought book\", \"amount\": -20 }" \
     http://localhost:5000/api/accounts/test/transactions
```

Тепер спробуйте оновити сторінку інформаційної панелі у браузері. Що відбувається? Чи бачите ви нову транзакцію?

Стан зберігається на невизначений час завдяки `localStorage`, але це також означає, що він ніколи не оновлюється, поки ви не вийдете з додатка і не ввійдете знову!

Однією з можливих стратегій вирішення цієї проблеми є перезавантаження даних облікового запису щоразу, коли завантажується інформаційна панель, щоб уникнути застарілих даних.

### Завдання

Створіть нову функцію `updateAccountData`:

```js
async function updateAccountData() {
  const account = state.account;
  if (!account) {
    return logout();
  }

  const data = await getAccount(account.user);
  if (data.error) {
    return logout();
  }

  updateState('account', data);
}
```

Цей метод перевіряє, чи ви зараз увійшли в систему, а потім перезавантажує дані облікового запису з сервера.

Створіть іншу функцію під назвою `refresh`:

```js
async function refresh() {
  await updateAccountData();
  updateDashboard();
}
```

Ця функція оновлює дані облікового запису, а потім оновлює HTML сторінки інформаційної панелі. Це те, що нам потрібно викликати, коли завантажується маршрут інформаційної панелі. Оновіть визначення маршруту:

```js
const routes = {
  '/login': { templateId: 'login' },
  '/dashboard': { templateId: 'dashboard', init: refresh }
};
```

Тепер спробуйте оновити інформаційну панель, вона повинна відображати оновлені дані облікового запису.

---

## 🚀 Виклик

Тепер, коли ми перезавантажуємо дані облікового запису щоразу, коли завантажується інформаційна панель, як ви думаєте, чи потрібно нам все ще з
[Тест після лекції](https://ff-quizzes.netlify.app/web/quiz/48)

## Завдання

[Реалізувати діалогове вікно "Додати транзакцію"](assignment.md)

Ось приклад результату після виконання завдання:

![Скріншот, що показує приклад діалогового вікна "Додати транзакцію"](../../../../translated_images/dialog.93bba104afeb79f12f65ebf8f521c5d64e179c40b791c49c242cf15f7e7fab15.uk.png)

---

**Відмова від відповідальності**:  
Цей документ було перекладено за допомогою сервісу автоматичного перекладу [Co-op Translator](https://github.com/Azure/co-op-translator). Хоча ми прагнемо до точності, будь ласка, зверніть увагу, що автоматичні переклади можуть містити помилки або неточності. Оригінальний документ на його рідній мові слід вважати авторитетним джерелом. Для критичної інформації рекомендується професійний людський переклад. Ми не несемо відповідальності за будь-які непорозуміння або неправильні тлумачення, що виникають внаслідок використання цього перекладу.